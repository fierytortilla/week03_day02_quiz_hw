# CRUD Quiz

Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

## MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the `Property` class?

We are instantiating instances of the 'Property' class in console.rb in order to create Property objects, whose information will be used to make a new row in the PostGresSQL data table.

Q2. Where are we defining the SQL that enables us to save the ruby `Property` object into the database?

We are defining the SQL table that enables to save the 'Property' objects into said table in properties.sql.

Q3. In `console.rb`, which lines modify the database?
Lines 4, 13, 22, 31, and 33 modify the database.

Q4. Why do we not define the id of a `Property` object at the point we instantiate it (‘new it up’)?

We do not define the ID of 'Property' object because, after we pass the object into our table, we use the ID generated by SQL (which has a column for the datatype SERIAL PRIMARY KEY). This ensures that our Ruby object and its pertinent row in the SQL table have the same ID number.

Q5. Where and how do we assign the id (that is generated by the database) to the ruby `Property` object?

We assign the id in the save method of the `Property` class, and we do this by running the command exec_prepared, which not only executes our prepared SQL query, but also returns a SQL object, which is an array that contains the SQL-generated ID. By accessing the ID using indexing of the array and the hash inside, we then assign it to the `Property` class attribute ID.

Q6. Why do we put a guard (an `if` clause) on the `@id` attribute in the constructor?

The `if` clause helps provide us with the ability to assign an instance of the `Property` class with an ID in the Ruby script instead of in SQL.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?

Instance methods can be run only by an object of a certain class, while class methods can be run without an instance of the class. Some CRUD actions, such as read or update or delete, are run to only perform their task on one row, while others are run to perform their task on multiple rows. Therefore, some CRUD actions are represented by instance methods in order to limit them accessing the information from one specific row in the table, while other CRUD actions are represented by class methods so that they can perform actions on multiple non-specific rows in the table.

Q8. What type of data structure is returned by calls to `db.exec_prepared()`? In the `save` method, how do we access the id from the returned data structure?

The data structure returned by `db.exec_prepared()` is an array of one (or potentially more) hashes. We index the first element of the array, and then we index the `id` of the hash object.

Q9. Why do we use prepared statements when performing database operations?

We use prepared statements in order to sanitize our data inputs of any inadvertent/purposeful malicious commands being slipped into our SQL command. Instead, such potentially harmful commands can be handled directly as values.

## Extension Questions

Look at the `find_by_id` and `find_by_address` methods in the `Property` class.

Q10. What do they take in as their arguments?

`find_by_id` takes in the ID number, while `find_by_address` takes in a string of an address.

Q11. What are their return values?

Both methods return a `Property` object.
